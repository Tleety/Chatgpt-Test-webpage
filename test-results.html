<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <title>Test Visualizer - My GitHub Page</title>
    <link rel="stylesheet" href="style.css">
    <style>
      .test-results-container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
      }

      .test-summary {
        background: #fff;
        border-radius: 8px;
        padding: 30px;
        margin: 20px 0;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        text-align: center;
      }

      .test-summary h2 {
        margin-top: 0;
        color: #333;
      }

      .summary-stats {
        display: flex;
        justify-content: center;
        gap: 40px;
        margin: 20px 0;
        flex-wrap: wrap;
      }

      .stat-item {
        text-align: center;
      }

      .stat-number {
        font-size: 2.5em;
        font-weight: bold;
        margin: 0;
      }

      .stat-label {
        color: #666;
        font-size: 0.9em;
        margin: 5px 0 0 0;
      }

      .stat-number.passed {
        color: #28a745;
      }

      .stat-number.failed {
        color: #dc3545;
      }

      .stat-number.total {
        color: #007bff;
      }

      .test-categories {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin: 20px 0;
      }

      .test-category {
        background: #fff;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }

      .category-title {
        font-size: 1.2em;
        font-weight: bold;
        margin: 0 0 15px 0;
        color: #333;
        border-bottom: 2px solid #f0f0f0;
        padding-bottom: 10px;
      }

      .test-item {
        display: flex;
        align-items: flex-start;
        padding: 8px 0;
        border-bottom: 1px solid #f5f5f5;
        flex-direction: column;
      }

      .test-item:last-child {
        border-bottom: none;
      }

      .test-item-header {
        display: flex;
        align-items: center;
        width: 100%;
      }

      .test-status {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        margin-right: 10px;
        flex-shrink: 0;
      }

      .test-status.passed {
        background: #28a745;
      }

      .test-status.failed {
        background: #dc3545;
      }

      .test-name {
        flex-grow: 1;
        font-size: 0.9em;
      }

      .test-error {
        margin-top: 8px;
        margin-left: 30px;
        padding: 10px;
        background: #fff5f5;
        border: 1px solid #fed7d7;
        border-radius: 4px;
        color: #c53030;
        font-size: 0.85em;
        font-family: 'Courier New', monospace;
        white-space: pre-wrap;
        word-break: break-word;
      }

      .test-execution {
        background: #fff;
        border-radius: 8px;
        padding: 20px;
        margin: 20px 0;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }

      .execution-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }

      .execution-title {
        font-size: 1.2em;
        font-weight: bold;
        color: #333;
      }

      .run-tests-btn {
        background: #007bff;
        color: white;
        border: none;
        border-radius: 5px;
        padding: 10px 20px;
        cursor: pointer;
        font-size: 1em;
        transition: background 0.2s;
      }

      .run-tests-btn:hover {
        background: #0056b3;
      }

      .run-tests-btn:disabled {
        background: #6c757d;
        cursor: not-allowed;
      }

      .execution-time {
        color: #666;
        font-size: 0.9em;
      }

      .loading {
        text-align: center;
        color: #666;
        font-style: italic;
      }

      .progress-bar {
        width: 100%;
        height: 8px;
        background: #f0f0f0;
        border-radius: 4px;
        margin: 10px 0;
        overflow: hidden;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #28a745, #20c997);
        width: 0%;
        transition: width 0.3s ease;
      }
    </style>
  </head>
  <body>
    <script src="top-bar.js"></script>
    
    <main class="test-results-container">
      <section class="hero">
        <h1>Test Visualizer Dashboard</h1>
        <p>Interactive visualization of all unit test results from the CI/CD pipeline</p>
      </section>

      <div class="test-execution">
        <div class="execution-header">
          <span class="execution-title">Test Execution</span>
          <button id="runTestsBtn" class="run-tests-btn">Run Tests</button>
        </div>
        <div class="progress-bar">
          <div id="progressFill" class="progress-fill"></div>
        </div>
        <div id="executionTime" class="execution-time">Click "Run Tests" to execute the test suite</div>
      </div>

      <div class="test-summary">
        <h2>Test Summary</h2>
        <div class="summary-stats">
          <div class="stat-item">
            <div id="totalTests" class="stat-number total">--</div>
            <div class="stat-label">Total Tests</div>
          </div>
          <div class="stat-item">
            <div id="passedTests" class="stat-number passed">--</div>
            <div class="stat-label">Passed</div>
          </div>
          <div class="stat-item">
            <div id="failedTests" class="stat-number failed">--</div>
            <div class="stat-label">Failed</div>
          </div>
        </div>
      </div>

      <div id="testCategories" class="test-categories">
        <div class="loading">Run tests to see detailed results...</div>
      </div>
    </main>

    <!-- Load all testable modules -->
    <script src="snake-game-logic.js"></script>
    <script src="todo-list-logic.js"></script>
    <script src="top-bar.js"></script>
    
    <script>
      // Simple Jest-like assertion library for browser
      function expect(actual) {
        return {
          toBe: function(expected) {
            if (actual !== expected) {
              throw new Error('Expected ' + JSON.stringify(expected) + ', but got ' + JSON.stringify(actual));
            }
          },
          toEqual: function(expected) {
            if (JSON.stringify(actual) !== JSON.stringify(expected)) {
              throw new Error('Expected ' + JSON.stringify(expected) + ', but got ' + JSON.stringify(actual));
            }
          },
          toHaveLength: function(expected) {
            if (actual.length !== expected) {
              throw new Error('Expected length ' + expected + ', but got ' + actual.length);
            }
          },
          toBeGreaterThan: function(expected) {
            if (actual <= expected) {
              throw new Error('Expected ' + actual + ' to be greater than ' + expected);
            }
          },
          toBeGreaterThanOrEqual: function(expected) {
            if (actual < expected) {
              throw new Error('Expected ' + actual + ' to be greater than or equal to ' + expected);
            }
          },
          toBeLessThan: function(expected) {
            if (actual >= expected) {
              throw new Error('Expected ' + actual + ' to be less than ' + expected);
            }
          },
          toBeDefined: function() {
            if (actual === undefined) {
              throw new Error('Expected value to be defined');
            }
          },
          toHaveProperty: function(prop) {
            if (!(prop in actual)) {
              throw new Error('Expected object to have property ' + prop);
            }
          },
          toContain: function(expected) {
            if (!actual.includes(expected)) {
              throw new Error('Expected "' + actual + '" to contain "' + expected + '"');
            }
          },
          not: {
            toBe: function(expected) {
              if (actual === expected) {
                throw new Error('Expected ' + JSON.stringify(actual) + ' not to be ' + JSON.stringify(expected));
              }
            }
          }
        };
      }

      // Browser-compatible test runner that mirrors the actual Jest tests
      // This runs the same test logic as the CI/CD pipeline
      
      var testSuites = {
        'SnakeGameLogic': {
          'Initialization': [
            {
              name: 'should initialize with correct default values',
              test: function() {
                var game = new SnakeGameLogic(400, 300);
                expect(game.gameWidth).toBe(400);
                expect(game.gameHeight).toBe(300);
                expect(game.CELL_SIZE).toBe(20);
                expect(game.score).toBe(0);
                expect(game.snake).toHaveLength(1);
                expect(game.direction).toEqual({ x: 20, y: 0 });
              }
            },
            {
              name: 'should place snake in center of game area',
              test: function() {
                var game = new SnakeGameLogic(400, 300);
                var expectedX = Math.floor(400 / 2 / 20) * 20; // 200
                var expectedY = Math.floor(300 / 2 / 20) * 20; // 140
                expect(game.snake[0]).toEqual({ x: expectedX, y: expectedY });
              }
            },
            {
              name: 'should place food at valid position',
              test: function() {
                var game = new SnakeGameLogic(400, 300);
                expect(game.food).toBeDefined();
                expect(game.food.x).toBeGreaterThanOrEqual(0);
                expect(game.food.x).toBeLessThan(400);
                expect(game.food.y).toBeGreaterThanOrEqual(0);
                expect(game.food.y).toBeLessThan(300);
                expect(game.food.x % 20).toBe(0);
                expect(game.food.y % 20).toBe(0);
              }
            }
          ],
          'Direction Changes': [
            {
              name: 'should allow valid direction changes',
              test: function() {
                var game = new SnakeGameLogic(400, 300);
                expect(game.changeDirection({ x: 0, y: -20 })).toBe(true); // up
                expect(game.direction).toEqual({ x: 0, y: -20 });
                expect(game.changeDirection({ x: -20, y: 0 })).toBe(true); // left
                expect(game.direction).toEqual({ x: -20, y: 0 });
              }
            },
            {
              name: 'should prevent 180-degree turns',
              test: function() {
                var game = new SnakeGameLogic(400, 300);
                expect(game.changeDirection({ x: -20, y: 0 })).toBe(false);
                expect(game.direction).toEqual({ x: 20, y: 0 }); // unchanged
              }
            },
            {
              name: 'should validate direction changes correctly',
              test: function() {
                var game = new SnakeGameLogic(400, 300);
                // Right direction
                game.direction = { x: 20, y: 0 };
                expect(game.isValidDirectionChange({ x: 0, y: 20 })).toBe(true);  // down
                expect(game.isValidDirectionChange({ x: 0, y: -20 })).toBe(true); // up
                expect(game.isValidDirectionChange({ x: -20, y: 0 })).toBe(false); // left (opposite)
              }
            }
          ],
          'Collision Detection': [
            {
              name: 'should detect wall collisions',
              test: function() {
                var game = new SnakeGameLogic(400, 300);
                expect(game.isWallCollision(-20, 140)).toBe(true);  // left wall
                expect(game.isWallCollision(400, 140)).toBe(true);  // right wall
                expect(game.isWallCollision(200, -20)).toBe(true);  // top wall
                expect(game.isWallCollision(200, 300)).toBe(true);  // bottom wall
                expect(game.isWallCollision(200, 140)).toBe(false); // inside bounds
              }
            },
            {
              name: 'should detect self collisions',
              test: function() {
                var game = new SnakeGameLogic(400, 300);
                // Add more segments to snake
                game.snake = [
                  { x: 200, y: 140 },
                  { x: 180, y: 140 },
                  { x: 160, y: 140 }
                ];
                expect(game.isSelfCollision(180, 140)).toBe(true);  // hits body
                expect(game.isSelfCollision(160, 140)).toBe(true);  // hits tail
                expect(game.isSelfCollision(220, 140)).toBe(false); // clear space
              }
            },
            {
              name: 'should detect food collisions',
              test: function() {
                var game = new SnakeGameLogic(400, 300);
                game.food = { x: 100, y: 100 };
                expect(game.isFoodCollision(100, 100)).toBe(true);
                expect(game.isFoodCollision(120, 100)).toBe(false);
              }
            }
          ],
          'Snake Movement': [
            {
              name: 'should move snake forward correctly',
              test: function() {
                var game = new SnakeGameLogic(400, 300);
                var initialHeadX = game.snake[0].x;
                var result = game.moveSnake();
                expect(result.collision).toBe(false);
                expect(result.ateFood).toBe(false);
                expect(game.snake[0].x).toBe(initialHeadX + 20);
                expect(game.snake).toHaveLength(1); // tail removed since no food eaten
              }
            },
            {
              name: 'should grow snake when eating food',
              test: function() {
                var game = new SnakeGameLogic(400, 300);
                var originalLength = game.snake.length;
                // Place food right in front of snake
                var headX = game.snake[0].x;
                var headY = game.snake[0].y;
                game.food = { x: headX + game.direction.x, y: headY + game.direction.y };
                var result = game.moveSnake();
                expect(result.ateFood).toBe(true);
                expect(game.snake).toHaveLength(originalLength + 1);
              }
            },
            {
              name: 'should detect collision with wall',
              test: function() {
                var game = new SnakeGameLogic(400, 300);
                // Move snake to edge
                game.snake[0] = { x: game.gameWidth - game.CELL_SIZE, y: 100 };
                var result = game.moveSnake();
                expect(result.collision).toBe(true);
              }
            },
            {
              name: 'should detect collision with self',
              test: function() {
                var game = new SnakeGameLogic(400, 300);
                // Create a snake that will collide with itself
                game.snake = [
                  { x: 100, y: 100 },
                  { x: 80, y: 100 },
                  { x: 60, y: 100 },
                  { x: 60, y: 80 },
                  { x: 80, y: 80 },
                  { x: 100, y: 80 }
                ];
                game.direction = { x: 0, y: 20 };
                var result = game.moveSnake();
                expect(result.collision).toBe(true);
              }
            }
          ],
          'Food Placement': [
            {
              name: 'should place food in valid grid positions',
              test: function() {
                var game = new SnakeGameLogic(400, 300);
                var food = game.placeFood();
                expect(food.x).toBeGreaterThanOrEqual(0);
                expect(food.x).toBeLessThan(400);
                expect(food.y).toBeGreaterThanOrEqual(0);
                expect(food.y).toBeLessThan(300);
                expect(food.x % 20).toBe(0);
                expect(food.y % 20).toBe(0);
              }
            },
            {
              name: 'should not place food on snake body',
              test: function() {
                var game = new SnakeGameLogic(400, 300);
                // Create a large snake
                for (var i = 0; i < 50; i++) {
                  game.snake.push({ x: i * 20, y: 0 });
                }
                var food = game.placeFood();
                var isOnSnake = game.snake.some(function(segment) {
                  return segment.x === food.x && segment.y === food.y;
                });
                expect(isOnSnake).toBe(false);
              }
            }
          ],
          'Game State': [
            {
              name: 'should return complete game state',
              test: function() {
                var game = new SnakeGameLogic(400, 300);
                var state = game.getGameState();
                expect(state).toHaveProperty('snake');
                expect(state).toHaveProperty('food');
                expect(state).toHaveProperty('score');
                expect(state).toHaveProperty('direction');
                expect(state.snake).toEqual(game.snake);
                expect(state.food).toEqual(game.food);
                expect(state.score).toBe(game.score);
                expect(state.direction).toEqual(game.direction);
              }
            },
            {
              name: 'should reset game state correctly',
              test: function() {
                var game = new SnakeGameLogic(400, 300);
                // Modify game state
                game.score = 100;
                game.snake.push({ x: 220, y: 140 });
                game.direction = { x: 0, y: -20 };
                
                game.reset();
                expect(game.score).toBe(0);
                expect(game.snake).toHaveLength(1);
                expect(game.direction).toEqual({ x: 20, y: 0 });
                expect(game.food).toBeDefined();
              }
            }
          ],
          'Edge Cases': [
            {
              name: 'should handle very small game area',
              test: function() {
                var game = new SnakeGameLogic(40, 40);
                expect(game.snake).toHaveLength(1);
                expect(game.food).toBeDefined();
                expect(game.snake[0].x).toBeGreaterThanOrEqual(0);
                expect(game.snake[0].x).toBeLessThan(40);
                expect(game.snake[0].y).toBeGreaterThanOrEqual(0);
                expect(game.snake[0].y).toBeLessThan(40);
              }
            },
            {
              name: 'should handle food placement when most spaces are occupied',
              test: function() {
                var game = new SnakeGameLogic(60, 60);
                // Fill most of the space with snake segments
                game.snake = [];
                for (var x = 0; x < 60; x += 20) {
                  for (var y = 0; y < 40; y += 20) {
                    game.snake.push({ x: x, y: y });
                  }
                }
                
                var food = game.placeFood();
                expect(food).toBeDefined();
                expect(food.x).toBeGreaterThanOrEqual(0);
                expect(food.y).toBeGreaterThanOrEqual(0);
                var isOnSnake = game.snake.some(function(segment) {
                  return segment.x === food.x && segment.y === food.y;
                });
                expect(isOnSnake).toBe(false);
              }
            }
          ],
          'High Score Management': [
            {
              name: 'getHighScores should return empty array when no scores exist',
              test: function() {
                var game = new SnakeGameLogic(400, 300);
                if (typeof localStorage !== 'undefined') {
                  localStorage.removeItem('snakeHighScores');
                }
                var scores = game.getHighScores();
                expect(scores).toEqual([]);
              }
            },
            {
              name: 'addHighScore should add score when list is empty',
              test: function() {
                var game = new SnakeGameLogic(400, 300);
                if (typeof localStorage !== 'undefined') {
                  localStorage.removeItem('snakeHighScores');
                }
                game.addHighScore(100, 'Player1');
                var scores = game.getHighScores();
                expect(scores).toHaveLength(1);
                expect(scores[0]).toEqual({ score: 100, name: 'Player1' });
              }
            }
          ]
        },
        'TodoListLogic': {
          'Initialization': [
            {
              name: 'should initialize with empty tasks array',
              test: function() {
                var todoList = new TodoListLogic();
                expect(todoList.tasks).toEqual([]);
                expect(todoList.nextId).toBeGreaterThan(0);
              }
            }
          ],
          'Adding Tasks': [
            {
              name: 'should add a valid task',
              test: function() {
                var todoList = new TodoListLogic();
                var result = todoList.addTask('New task');
                expect(result).toBe(true);
                expect(todoList.tasks).toHaveLength(1);
                expect(todoList.tasks[0].text).toBe('New task');
                expect(todoList.tasks[0].completed).toBe(false);
                expect(todoList.tasks[0].id).toBeGreaterThan(0);
              }
            },
            {
              name: 'should not add empty tasks',
              test: function() {
                var todoList = new TodoListLogic();
                expect(todoList.addTask('')).toBe(false);
                expect(todoList.addTask('   ')).toBe(false);
                expect(todoList.addTask(null)).toBe(false);
                expect(todoList.addTask(undefined)).toBe(false);
                expect(todoList.tasks).toHaveLength(0);
              }
            }
          ]
        },
        'TopBarComponent': {
          'createTopBar function': [
            {
              name: 'should include version information in the top bar',
              test: function() {
                var topBarHTML = createTopBar();
                expect(topBarHTML).toContain('class="version"');
                expect(topBarHTML).toContain('v1.0.0');
              }
            },
            {
              name: 'should maintain existing structure with logo, title, and navigation',
              test: function() {
                var topBarHTML = createTopBar();
                expect(topBarHTML).toContain('class="top-bar"');
                expect(topBarHTML).toContain('class="logo"');
                expect(topBarHTML).toContain('My GitHub Page');
                expect(topBarHTML).toContain('class="navigation"');
                expect(topBarHTML).toContain('Home');
                expect(topBarHTML).toContain('Projects');
                expect(topBarHTML).toContain('Test Visualizer');
              }
            }
          ]
        },
        'SnakeGameUI': {
          'UI Tests': [
            {
              name: 'should prevent default behavior for arrow keys',
              test: function() {
                var preventDefaultCalled = false;
                var mockEvent = {
                  code: 'ArrowUp',
                  preventDefault: function() { preventDefaultCalled = true; }
                };
                
                // Simulate the keydown handler logic
                var keys = {};
                var gameRunning = true;
                
                if (mockEvent.code === 'Space' && !gameRunning) {
                  mockEvent.preventDefault();
                }
                
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(mockEvent.code)) {
                  mockEvent.preventDefault();
                }
                
                expect(preventDefaultCalled).toBe(true);
              }
            },
            {
              name: 'should not prevent default for non-arrow keys',
              test: function() {
                var preventDefaultCalled = false;
                var mockEvent = {
                  code: 'KeyA',
                  preventDefault: function() { preventDefaultCalled = true; }
                };
                
                // Simulate the keydown handler logic
                var keys = {};
                var gameRunning = true;
                
                if (mockEvent.code === 'Space' && !gameRunning) {
                  mockEvent.preventDefault();
                }
                
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(mockEvent.code)) {
                  mockEvent.preventDefault();
                }
                
                expect(preventDefaultCalled).toBe(false);
              }
            }
          ]
        }
      };

      // Run all test suites
      function runTestSuite() {
        var results = {};
        var totalTests = 0;
        var passedTests = 0;

        for (var suiteName in testSuites) {
          var suiteCategories = testSuites[suiteName];
          for (var categoryName in suiteCategories) {
            var tests = suiteCategories[categoryName];
            var fullCategoryName = suiteName + ' - ' + categoryName;
            results[fullCategoryName] = [];
            
            for (var i = 0; i < tests.length; i++) {
              var testObj = tests[i];
              totalTests++;
              var testResult = false;
              var errorMessage = null;
              
              try {
                testObj.test();
                testResult = true;
              } catch (error) {
                testResult = false;
                errorMessage = error.message;
              }
              
              results[fullCategoryName].push({
                name: testObj.name,
                passed: testResult,
                error: errorMessage
              });
              
              if (testResult) passedTests++;
            }
          }
        }

        return {
          results: results,
          summary: {
            total: totalTests,
            passed: passedTests,
            failed: totalTests - passedTests
          }
        };
      }

      function updateProgressBar(progress) {
        document.getElementById('progressFill').style.width = progress + '%';
      }

      function updateSummary(summary) {
        document.getElementById('totalTests').textContent = summary.total;
        document.getElementById('passedTests').textContent = summary.passed;
        document.getElementById('failedTests').textContent = summary.failed;
      }

      function displayResults(results) {
        var container = document.getElementById('testCategories');
        container.innerHTML = '';

        for (var category in results) {
          var tests = results[category];
          var categoryDiv = document.createElement('div');
          categoryDiv.className = 'test-category';
          
          var title = document.createElement('div');
          title.className = 'category-title';
          title.textContent = category;
          categoryDiv.appendChild(title);

          for (var i = 0; i < tests.length; i++) {
            var test = tests[i];
            var testItem = document.createElement('div');
            testItem.className = 'test-item';
            
            var testHeader = document.createElement('div');
            testHeader.className = 'test-item-header';
            
            var status = document.createElement('div');
            status.className = 'test-status ' + (test.passed ? 'passed' : 'failed');
            
            var name = document.createElement('div');
            name.className = 'test-name';
            name.textContent = test.name;
            
            testHeader.appendChild(status);
            testHeader.appendChild(name);
            testItem.appendChild(testHeader);
            
            // Add error details for failed tests
            if (!test.passed && test.error) {
              var errorDiv = document.createElement('div');
              errorDiv.className = 'test-error';
              errorDiv.textContent = test.error;
              testItem.appendChild(errorDiv);
            }
            
            categoryDiv.appendChild(testItem);
          }

          container.appendChild(categoryDiv);
        }
      }

      function runTests() {
        return new Promise(function(resolve) {
          var runButton = document.getElementById('runTestsBtn');
          var executionTime = document.getElementById('executionTime');
          
          runButton.disabled = true;
          runButton.textContent = 'Running Tests...';
          executionTime.textContent = 'Executing tests...';
          
          var startTime = Date.now();
          
          // Simulate test execution with progress updates
          updateProgressBar(0);
          
          // Calculate total number of tests for progress
          var totalTestCount = 0;
          for (var suiteName in testSuites) {
            var suiteCategories = testSuites[suiteName];
            for (var categoryName in suiteCategories) {
              var tests = suiteCategories[categoryName];
              totalTestCount += tests.length;
            }
          }
          
          var results = {};
          var currentTestIndex = 0;
          var totalTests = 0;
          var passedTests = 0;
          
          var processCategories = Object.keys(testSuites);
          var categoryIndex = 0;
          
          function processNextCategory() {
            if (categoryIndex >= processCategories.length) {
              var endTime = Date.now();
              var duration = endTime - startTime;
              
              var summary = {
                total: totalTests,
                passed: passedTests,
                failed: totalTests - passedTests
              };

              updateSummary(summary);
              displayResults(results);
              
              executionTime.textContent = 'Tests completed in ' + duration + 'ms';
              runButton.disabled = false;
              runButton.textContent = 'Run Tests Again';
              resolve();
              return;
            }
            
            var suiteName = processCategories[categoryIndex];
            var suiteCategories = testSuites[suiteName];
            var categories = Object.keys(suiteCategories);
            var subCategoryIndex = 0;
            
            function processNextSubCategory() {
              if (subCategoryIndex >= categories.length) {
                categoryIndex++;
                setTimeout(processNextCategory, 10);
                return;
              }
              
              var categoryName = categories[subCategoryIndex];
              var tests = suiteCategories[categoryName];
              var fullCategoryName = suiteName + ' - ' + categoryName;
              results[fullCategoryName] = [];
              
              var testIndex = 0;
              
              function processNextTest() {
                if (testIndex >= tests.length) {
                  subCategoryIndex++;
                  setTimeout(processNextSubCategory, 10);
                  return;
                }
                
                var testObj = tests[testIndex];
                totalTests++;
                currentTestIndex++;
                var testResult = false;
                var errorMessage = null;
                
                try {
                  testObj.test();
                  testResult = true;
                } catch (error) {
                  testResult = false;
                  errorMessage = error.message;
                }
                
                results[fullCategoryName].push({
                  name: testObj.name,
                  passed: testResult,
                  error: errorMessage
                });
                if (testResult) passedTests++;
                
                // Update progress
                var progress = (currentTestIndex / totalTestCount) * 100;
                updateProgressBar(progress);
                
                testIndex++;
                setTimeout(processNextTest, 30);
              }
              
              processNextTest();
            }
            
            processNextSubCategory();
          }
          
          processNextCategory();
        });
      }

      // Event listeners
      document.getElementById('runTestsBtn').addEventListener('click', runTests);

      // Auto-run tests on page load
      window.addEventListener('load', function() {
        setTimeout(runTests, 500);
      });
    </script>
  </body>
</html>