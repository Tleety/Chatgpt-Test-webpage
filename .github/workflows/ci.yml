name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    name: Detect Changes
    outputs:
      wasm_changed: ${{ steps.changes.outputs.wasm_changed }}
      jekyll_changed: ${{ steps.changes.outputs.jekyll_changed }}
      snake_changed: ${{ steps.changes.outputs.snake_changed }}
      main_site_changed: ${{ steps.changes.outputs.main_site_changed }}
      tests_changed: ${{ steps.changes.outputs.tests_changed }}
      ci_changed: ${{ steps.changes.outputs.ci_changed }}
      build_strategy: ${{ steps.changes.outputs.build_strategy }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Detect component changes
      id: changes
      run: |
        chmod +x scripts/detect-changes.sh
        
        # For pull requests, compare against target branch
        if [[ "${{ github.event_name }}" == "pull_request" ]]; then
          BASE_REF="${{ github.event.pull_request.base.sha }}"
        else
          # For pushes, compare against previous commit
          BASE_REF="HEAD~1"
        fi
        
        # Run change detection
        output=$(./scripts/detect-changes.sh "$BASE_REF")
        echo "$output"
        
        # Extract variables from output
        eval $(echo "$output" | grep -E '^(WASM_CHANGED|JEKYLL_CHANGED|SNAKE_CHANGED|MAIN_SITE_CHANGED|TESTS_CHANGED|CI_CHANGED|BUILD_STRATEGY)=')
        
        # Set outputs for subsequent jobs
        echo "wasm_changed=$WASM_CHANGED" >> $GITHUB_OUTPUT
        echo "jekyll_changed=$JEKYLL_CHANGED" >> $GITHUB_OUTPUT
        echo "snake_changed=$SNAKE_CHANGED" >> $GITHUB_OUTPUT
        echo "main_site_changed=$MAIN_SITE_CHANGED" >> $GITHUB_OUTPUT
        echo "tests_changed=$TESTS_CHANGED" >> $GITHUB_OUTPUT
        echo "ci_changed=$CI_CHANGED" >> $GITHUB_OUTPUT
        echo "build_strategy=$BUILD_STRATEGY" >> $GITHUB_OUTPUT

  test:
    runs-on: ubuntu-latest
    name: Selective Tests
    needs: detect-changes
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Setup Go for WASM (if needed)
      if: needs.detect-changes.outputs.wasm_changed == 'true' || needs.detect-changes.outputs.build_strategy == 'full'
      uses: actions/setup-go@v4
      with:
        go-version: '1.21'
        
    - name: Build Go WASM module for tests (if needed)
      if: needs.detect-changes.outputs.wasm_changed == 'true' || needs.detect-changes.outputs.build_strategy == 'full'
      run: |
        cd go-wasm-game
        GOOS=js GOARCH=wasm go build -o game.wasm
      
    - name: Run selective tests
      run: |
        chmod +x scripts/selective-test.sh
        ./scripts/selective-test.sh "${{ needs.detect-changes.outputs.build_strategy }}"
      
    - name: Generate test results for test visualizer
      run: |
        strategy="${{ needs.detect-changes.outputs.build_strategy }}"
        if [[ "$strategy" == "full" ]]; then
          npm test -- --json --outputFile=tests/test-results.json
        else
          echo "Skipping full test results generation for selective build strategy: $strategy"
          # Create a minimal test results file
          echo '{"success": true, "numTotalTests": 0, "numPassedTests": 0, "numFailedTests": 0, "testResults": []}' > tests/test-results.json
        fi
        
        node -e "
        const fs = require('fs');
        try {
          const testResults = JSON.parse(fs.readFileSync('tests/test-results.json', 'utf8'));
          const summary = {
            timestamp: new Date().toISOString(),
            success: testResults.success,
            numTotalTests: testResults.numTotalTests,
            numPassedTests: testResults.numPassedTests,
            numFailedTests: testResults.numFailedTests,
            buildStrategy: '${{ needs.detect-changes.outputs.build_strategy }}',
            testSuites: testResults.testResults.map(suite => ({
              name: suite.name.replace(/.*\//, '').replace('.test.js', ''),
              status: suite.status,
              numPassingTests: suite.numPassingTests,
              numFailingTests: suite.numFailingTests,
              file: suite.name.replace(/.*\//, '')
            }))
          };
          fs.writeFileSync('tests/test-summary.json', JSON.stringify(summary, null, 2));
          console.log('Test summary saved to tests/test-summary.json');
        } catch (error) {
          console.log('Failed to generate test summary:', error.message);
          fs.writeFileSync('tests/test-summary.json', JSON.stringify({
            timestamp: new Date().toISOString(),
            success: false,
            numTotalTests: 0,
            numPassedTests: 0,
            numFailedTests: 0,
            buildStrategy: '${{ needs.detect-changes.outputs.build_strategy }}',
            testSuites: [],
            error: 'Failed to parse test results'
          }, null, 2));
        }
        "
      if: always()

  selective-build:
    runs-on: ubuntu-latest
    name: Selective Build
    needs: [detect-changes, test]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Setup Go for WASM (if needed)
      if: needs.detect-changes.outputs.wasm_changed == 'true' || needs.detect-changes.outputs.build_strategy == 'full'
      uses: actions/setup-go@v4
      with:
        go-version: '1.21'
        
    - name: Setup Ruby for Jekyll (if needed)
      if: needs.detect-changes.outputs.jekyll_changed == 'true' || needs.detect-changes.outputs.build_strategy == 'full'
      uses: ruby/setup-ruby@v1
      with:
        ruby-version: '3.0'
        bundler-cache: true
        working-directory: ./jekyll-site
        
    - name: Run selective build
      run: |
        chmod +x scripts/selective-build.sh
        ./scripts/selective-build.sh "${{ needs.detect-changes.outputs.build_strategy }}"
        
    - name: Log build summary
      run: |
        echo "=========================================="
        echo "Build completed with strategy: ${{ needs.detect-changes.outputs.build_strategy }}"
        echo "Components changed:"
        echo "  WASM: ${{ needs.detect-changes.outputs.wasm_changed }}"
        echo "  Jekyll: ${{ needs.detect-changes.outputs.jekyll_changed }}"
        echo "  Snake: ${{ needs.detect-changes.outputs.snake_changed }}"
        echo "  Main Site: ${{ needs.detect-changes.outputs.main_site_changed }}"
        echo "  Tests: ${{ needs.detect-changes.outputs.tests_changed }}"
        echo "  CI/CD: ${{ needs.detect-changes.outputs.ci_changed }}"
        echo "=========================================="

  deploy:
    runs-on: ubuntu-latest
    name: Deploy to GitHub Pages
    needs: [detect-changes, test, selective-build]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Run tests and generate results for deployment
      run: |
        strategy="${{ needs.detect-changes.outputs.build_strategy }}"
        if [[ "$strategy" == "full" ]]; then
          npm test -- --json --outputFile=tests/test-results.json || echo "Tests failed but continuing deployment"
        else
          echo "Skipping full test execution for deployment with strategy: $strategy"
          echo '{"success": true, "numTotalTests": 0, "numPassedTests": 0, "numFailedTests": 0, "testResults": []}' > tests/test-results.json
        fi
        
        node -e "
        const fs = require('fs');
        try {
          const testResults = JSON.parse(fs.readFileSync('tests/test-results.json', 'utf8'));
          const summary = {
            timestamp: new Date().toISOString(),
            success: testResults.success,
            numTotalTests: testResults.numTotalTests,
            numPassedTests: testResults.numPassedTests,
            numFailedTests: testResults.numFailedTests,
            buildStrategy: '${{ needs.detect-changes.outputs.build_strategy }}',
            testSuites: testResults.testResults.map(suite => ({
              name: suite.name.replace(/.*\//, '').replace('.test.js', ''),
              status: suite.status,
              numPassingTests: suite.numPassingTests,
              numFailingTests: suite.numFailingTests,
              file: suite.name.replace(/.*\//, '')
            }))
          };
          fs.writeFileSync('tests/test-summary.json', JSON.stringify(summary, null, 2));
          console.log('Test summary saved for deployment');
        } catch (error) {
          console.log('Failed to generate test summary:', error.message);
          fs.writeFileSync('tests/test-summary.json', JSON.stringify({
            timestamp: new Date().toISOString(),
            success: false,
            numTotalTests: 0,
            numPassedTests: 0,
            numFailedTests: 0,
            buildStrategy: '${{ needs.detect-changes.outputs.build_strategy }}',
            testSuites: [],
            error: 'Failed to parse test results'
          }, null, 2));
        }
        "
      if: always()
      
    - name: Generate deployment info
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        npm run generate-deployment-info
        git add -f deployment.json tests/test-summary.json
        git commit -m "chore: update deployment info and test results [skip ci]" || echo "No deployment info changes to commit"
        git push || echo "No changes to push"
      
    - name: Install dependencies (post deployment info generation)
      run: npm ci
      
    - name: Setup Pages
      uses: actions/configure-pages@v3
      
    - name: Setup Go for WASM (if needed for deployment)
      if: needs.detect-changes.outputs.wasm_changed == 'true' || needs.detect-changes.outputs.build_strategy == 'full'
      uses: actions/setup-go@v4
      with:
        go-version: '1.21'
        
    - name: Build Go WASM module (if needed for deployment)
      if: needs.detect-changes.outputs.wasm_changed == 'true' || needs.detect-changes.outputs.build_strategy == 'full'
      run: |
        cd go-wasm-game
        GOOS=js GOARCH=wasm go build -o game.wasm
        
    - name: Setup Ruby for Jekyll (if needed for deployment)
      if: needs.detect-changes.outputs.jekyll_changed == 'true' || needs.detect-changes.outputs.build_strategy == 'full'
      uses: ruby/setup-ruby@v1
      with:
        ruby-version: '3.0'
        bundler-cache: true
        working-directory: ./jekyll-site
        
    - name: Build Jekyll site (if needed for deployment)
      if: needs.detect-changes.outputs.jekyll_changed == 'true' || needs.detect-changes.outputs.build_strategy == 'full'
      run: |
        cd jekyll-site
        gem install bundler jekyll
        bundle install
        bundle exec jekyll build
        
    - name: Prepare deployment artifacts
      run: |
        mkdir -p _deployment
        rsync -av --exclude='_deployment' --exclude='node_modules' --exclude='.git' . _deployment/
        if [ -f deployment.json ]; then
          cp deployment.json _deployment/deployment.json
        fi
        
        echo "Deployment prepared with strategy: ${{ needs.detect-changes.outputs.build_strategy }}"
        
    - name: Upload artifact
      uses: actions/upload-pages-artifact@v3
      with:
        path: '_deployment'
        
    - name: Deploy to GitHub Pages
      id: deployment
      uses: actions/deploy-pages@v4

permissions:
  contents: write
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false